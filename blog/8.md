### 一种可以自我修改的计算机器

有这样一堆可以存储数字的方格：

|0|0|0|0|0|0|0|0|
|-|-|-|-|-|-|-|-|
|0|0|0|0|0|0|0|0|
|0|0|0|0|0|0|0|0|
|0|0|0|0|0|0|0|0|
|...|...|...||||||

如果我们可以对其中任意2个方格进行“或"运算并写入任意1个方格，或者对任意1个方格进行"非"运算并写入任意1个方格，那么由无限个方格和操作组成的机器是图灵完备的吗？答案是肯定的，下面我将给出这种机器的一个实例：

该机器具有如下特点：

- 该机器的所有状态几乎都由自身描述，并且它可以直接改变自己的内部状态（即自我修改，与冯·诺依曼架构类似但又不相同），不像图灵机一样内部状态和纸带是分离的。
- 它的状态转移是清晰可见的，而图灵机由一个内部状态（格局）转移到另一个状态像幽灵一样。
- 它有清晰可见的时序实现，而《编码：隐匿在计算机软硬件背后的语言》一书中构造的物理机器时序并不是显而易见的。
- 它使用表格表示，不需要画逻辑电路图，也不需要使用硬件描述语言（HDL）。
- 它既可以很容易地进行书面表示（即人类可读），又可以很容易地构造实际的物理机器。

该机器实例的构成：

1. 有限个方格，每个方格可以存储16位二进制数，即可以表达十进制数0到65535，为了增加可读性本文所有数字都用十进制表示。
2. 每行放8个方格，每个方格都有一个编号，编号从0开始，从左往右递增，从上往下换行，即行主序。
3. 一堆方格可以组成模块，每个模块只能寻址到自身，模块与模块之间可以硬连线。增加模块的目的是增加可读性，如果所有数字都写在一个模块里很可能不是人类可读的。
4. 每个模块都有一个自身的振荡器（即时序），但所有振荡器都是同源的。
5. 每个模块的行为比较简单，它由一个振荡器驱动，反复执行动作。首先，读取第0号方格中的数字，设为a，再读取a方格中的数字，设为b，根据b的值决定接下来的动作：

- 若b为1，读取b后面的3个方格c、d、e，再分别读取c、d的值所代表的方格，进行“或”运算并写入e所代表的方格。接下来再读取e后面的3个方格f、g、h，再分别读取f、g的值所代表的方格，进行“或”运算并写入h所代表的方格。（可以看到该步骤执行了两次16位“或”运算）
- 若b为2，读取b后面的2个方格o、p，再读取o的值所代表的方格，进行“非”运算并写入p所代表的方格。接下来再读取p后面的3个方格q、r、s，再分别读取q、r的值所代表的方格，进行“或”运算并写入s所代表的方格。（可以看到该步骤执行了一次16位“非”运算和一次16位“或”运算）
- 若b为3，读取b后面的3个方格位c、d、e（按位寻址，只读1位），再分别读取c、d的值所代表的方格位，进行“或”运算并写入e所代表的方格位中。接下来再读取e后面的3个方格f、g、h，再分别读取f、g的值所代表的方格，进行“或”运算并写入h所代表的方格。（可以看到该步骤执行了一次1位的“或”运算和一次16位的“或”运算）

下面通过一个例子来说明：

|8|0|0|0|0|0|0|0|
|-|-|-|-|-|-|-|-|
|2|5|2|1|14|0|16|0|
|2|6|3|1|22|0|24|0|
|1|2|3|7|1|31|0|32|
|2|7|7|1|38|0|8|0|

该模块的执行流程是：

- 先读取0号方格，即第一行第一列，读到了8，再读取8号方格，即第二行第一列，读到了2，发现这是第二种指令，接下来的两个数字是5和2，所以对第5号方格执行非运算并写入第2号方格。再后面是1、14、0，所以对1号方格和14号方格执行或运算并写入0号方格。可以看到14号方格的值是16，刚好是第三行第一列的编号，而1号方格的值是0，0或16等于16，这就是将16写入了0号方格，这是实现绝对跳转的关键。（这里的“CPU”执行完一条“指令”并不会自动转到下一条“指令”，因此需要我们手动实现）
- 接下来进入下一个振荡器周期，读取0号方格，读到了16，再读取16号方格，读到了2，发现还是第二种指令，执行流程和上面一样。最后24被写入了0号方格。
- 接下来进入下一个振荡器周期，读取0号方格，读到了24，再读取24号方格，读到了1，发现是第一种指令，将2号方格和3号方格进行或运算并写入7号方格，再将1号方格和31号方格进行或运算并写入0号方格，31号方格的值是32，即将32写入了0号方格。
- 接下来进入下一个振荡器周期，读取0号方格，读到了32，再读取32号方格，读到了2，发现是第二种指令，执行非运算和或运算后，最终8被写入了0号方格。至此0号方格又回到了最初的值，开始了新一轮的循环。

那么这个模块到底在干嘛？其实它就是一个16位2输入与门，根据德·摩根定律，A * B = ~ (~ A + ~ B)，假设每条指令的计算耗时均不超过1个时间单位，我们将2个输入分别放入5号和6号方格，等待4个时间单位后，7号方格就得到了结果。由于与门不在我们的操作列表里，所以这里我们用或门和非门实现了与门。我们把输入和输出方格标识出来，对这个模块进行重新描述如下：（注意表格中第一行的加粗字体并不表示什么含义，只是MarkDown的表格第一行会自动加粗）

#### A：16位2输入与门，振荡器周期1个时间单位，计算耗时4个时间单位

|8|0|0|0|0|in|in|out|
|-|-|-|-|-|-|-|-|
|2|5|2|1|14|0|16|0|
|2|6|3|1|22|0|24|0|
|1|2|3|7|1|31|0|32|
|2|7|7|1|38|0|8|0|

接下来基于2输入与门，我们就可以实现3输入与门：

#### B：16位3输入与门，振荡器周期4个时间单位，计算耗时20个时间单位

|8|0|0|0|in|in|in|out|
|-|-|-|-|-|-|-|-|
|1|1|4|Aa5|1|15|0|16|
|1|1|5|Aa6|1|23|0|24|
|1|1|Aa7|Ab5|1|31|0|32|
|1|1|6|Ab6|1|39|0|40|
|1|1|Ab7|7|1|47|0|8|

表格中大写字母开头的方格Aa5表示该方格硬连线到模块A的第5号方格，是编码为a的实例，就是说Aa和Ab都是2输入与门，但他们是两个不同的实例。另外由于该模块用到了A模块，所以它必须要等待A模块操作完，振荡器周期至少是4个时间单位。

同样的，为了实现一点有趣的功能，我们还需要实现其他的基本模块：

#### X：16位2输入异或门，振荡器周期4个时间单位，计算耗时28个时间单位

|8|0|0|0|0|in|in|out|
|-|-|-|-|-|-|-|-|
|2|5|2|1|14|0|16|0|
|2|6|3|1|22|0|24|0|
|1|1|2|Aa5|1|31|0|32|
|1|1|6|Aa6|1|39|0|40|
|1|1|3|Ab5|1|47|0|48|
|1|1|5|Ab6|1|55|0|56|
|1|Aa7|Ab7|7|1|63|0|8|

#### C：16位4输入或门，振荡器周期1个时间单位，计算耗时3个时间单位

|8|0|0|in|in|in|in|out|
|-|-|-|-|-|-|-|-|
|1|3|4|7|1|15|0|16|
|1|5|6|2|1|23|0|24|
|1|2|7|7|1|31|0|8|

#### P：1位全加器（依然使用16位运算），振荡器周期4个时间单位，计算耗时136个时间单位

|16|0|0|in_carry|in|in|out|out_carry|
|-|-|-|-|-|-|-|-|
|0|0|0|0|0|0|0|0|
|2|3|11|1|22|0|24|0|
|2|4|12|1|30|0|32|0|
|2|5|13|1|38|0|40|0|
|1|1|11|Ba4|1|47|0|48|
|1|1|12|Ba5|1|55|0|56|
|1|1|5|Ba6|1|63|0|64|
|1|1|11|Bb4|1|71|0|72|
|1|1|4|Bb5|1|79|0|80|
|1|1|13|Bb6|1|87|0|88|
|1|1|3|Bc4|1|95|0|96|
|1|1|12|Bc5|1|103|0|104|
|1|1|13|Bc6|1|111|0|112|
|1|1|3|Bd4|1|119|0|120|
|1|1|4|Bd5|1|127|0|128|
|1|1|5|Bd6|1|135|0|136|
|1|1|11|Be4|1|143|0|144|
|1|1|4|Be5|1|151|0|152|
|1|1|5|Be6|1|159|0|160|
|1|1|3|Bf4|1|167|0|168|
|1|1|12|Bf5|1|175|0|176|
|1|1|5|Bf6|1|183|0|184|
|1|1|3|Bg4|1|191|0|192|
|1|1|4|Bg5|1|199|0|200|
|1|1|13|Bg6|1|207|0|208|
|1|1|Ba7|Ca3|1|215|0|216|
|1|1|Bb7|Ca4|1|223|0|224|
|1|1|Bc7|Ca5|1|231|0|232|
|1|1|Bd7|Ca6|1|239|0|240|
|1|1|Be7|Cb3|1|247|0|248|
|1|1|Bf7|Cb4|1|255|0|256|
|1|1|Bg7|Cb5|1|263|0|264|
|1|1|Bd7|Cb6|1|271|0|272|
|1|1|Ca7|6|1|279|0|280|
|1|1|Cb7|7|1|287|0|16|

#### Q：5位加法器（存储单元依然为16位），振荡器周期136个时间单位，计算耗时2720个时间单位

|8|0|0|0|0|in|in|out|
|-|-|-|-|-|-|-|-|
|3|1*16|1*16|Pa3*16|1|15|0|16|
|3|1*16|5*16|Pa4*16|1|23|0|24|
|3|1*16|6*16|Pa5*16|1|31|0|32|
|3|1*16|Pa7*16|Pa3*16+1|1|39|0|40|
|3|1*16|5*16+1|Pa4*16+1|1|47|0|48|
|3|1*16|6*16+1|Pa5*16+1|1|55|0|56|
|3|1*16|Pa7*16+1|Pa3*16+2|1|63|0|64|
|3|1*16|5*16+2|Pa4*16+2|1|71|0|72|
|3|1*16|6*16+2|Pa5*16+2|1|79|0|80|
|3|1*16|Pa7*16+2|Pa3*16+3|1|87|0|88|
|3|1*16|5*16+3|Pa4*16+3|1|95|0|96|
|3|1*16|6*16+3|Pa5*16+3|1|103|0|104|
|3|1*16|Pa7*16+3|Pa3*16+4|1|111|0|112|
|3|1*16|5*16+4|Pa4*16+4|1|119|0|120|
|3|1*16|6*16+4|Pa5*16+4|1|127|0|128|
|3|1*16|Pa6*16|7*16|1|135|0|136|
|3|1*16|Pa6*16+1|7*16+1|1|143|0|144|
|3|1*16|Pa6*16+2|7*16+1|1|151|0|152|
|3|1*16|Pa6*16+3|7*16+1|1|159|0|160|
|3|1*16|Pa6*16+4|7*16+1|1|167|0|8|

这里用到了第三种指令按位或运算，所以表格中的1 * 16即16，Pa3 * 16即Pa48，按位寻址。另外进行位运算前无需清零，因为存储器在一开始已经全部清零。

#### M：5位比较器（存储单元依然为16位），相等输出0，不相等输出1，振荡器周期28个时间单位，计算耗时224个时间单位

|8|0|0|0|0|in|in|out|
|-|-|-|-|-|-|-|-|
|1|1|5|Xa5|1|15|0|16|
|1|1|6|Xa6|1|23|0|24|
|3|1*16|Xa7*16|Ca3*16|1|31|0|32|
|3|1*16|Xa7*16+1|Ca4*16|1|39|0|40|
|3|1*16|Xa7*16+2|Ca5*16|1|47|0|48|
|3|1*16|Xa7*16+3|Ca6*16|1|55|0|56|
|3|1*16|Ca7*16|7*16|1|63|0|64|
|3|Ca7*16|Xa7*16+4|Ca7*16|1|71|0|8|

#### S：16位比较选择器，比较前2个输入的数字（最大5位），相等则输出后2个输入的数字的前者，不相等则输出后2个输入的数字的后者，振荡器周期224个时间单位，计算耗时1568个时间单位

|16|0|8|in_num|in_num|in_addr|in_addr|out_addr|
|-|-|-|-|-|-|-|-|
|0|0|0|0|0|0|0|0|
|1|1|3|Ma5|1|23|0|24|
|1|1|4|Ma6|1|31|0|32|
|1|2|Ma7|Ma7|1|39|0|40|
|1|1|5|8|1|47|0|48|
|1|1|6|9|1|55|0|56|
|1|1|Ma7|66|1|63|0|64|
|1|1|0|7|1|71|0|16|

这里需要一点特殊的技巧，将5号方格的in_addr和6号方格的in_addr分别写入8号和9号方格，然后因此M模块的输出是0或者1，所以第五行将2号方格的8与Ma7进行或运算相当于对Ma7加8，即0+8=8或者1+8=9。另外66号方格最开始是0，但会被倒数第二行的指令修改，即自修改，只有这种自修改的方法才能实现条件选择。

#### Z：循环求和模块，计算1+2+3+4+5，振荡器周期2720个时间单位，计算耗时149600个时间单位

|8|0|8|88|1|1|6|0|
|-|-|-|-|-|-|-|-|
|1|1|5|Qa5|1|15|0|16|
|1|1|7|Qa6|1|23|0|24|
|1|1|Qa7|7|1|31|0|32|
|1|1|4|Qa5|1|39|0|40|
|1|1|5|Qa6|1|47|0|48|
|1|1|Qa7|5|1|55|0|56|
|1|1|5|Sa3|1|63|0|64|
|1|1|6|Sa4|1|71|0|72|
|1|1|3|Sa5|1|79|0|80|
|1|1|2|Sa6|1|87|0|88|
|1|1|Sa7|95|1|95|0|0|

2号方格的8是第二行的起始编号，3号方格的88是最后一行的起始编号，4号方格用来每次加1，5号方格是循环变量，初始化为1，6号方格的6是循环变量的终止值。注意最后一个方格即95号方格，它的初始值是0，但它会被最后一行的指令根据S模块的输出值修改（又是自修改），也就是如果Sa3等于Sa4，则把Sa5（88）放入95号方格，如果Sa3不等于Sa4，则把Sa6（8）放入95号方格。所以最后一条指令相当于实现了条件跳转，根据情况选择跳转到8或者88。

经过149600个时间单位后，我们在右上角（即7号方格）看到了计算1+2+3+4+5的结果15，最终该模块陷入了执行最后一行指令的无限循环。
